2014.8.4:建立hg
2014.8.4:添加variant
2014.8.5:添加flex和bison，初步添加语法
2014.8.5:bison编译通过
2014.8.5:程序编译通过，下一步加test测试内容
2014.8.13:添加syntree，下一步加语法树的生成，后面才能根据语法树编译成字节码
2014.8.14:加解析log
2014.8.15:加解析log，加新stmt
2014.8.16:加内存管理
2014.8.22:加func desc node
2014.8.26:加syntree node
2014.8.27:加syntree dump
2014.9.1:加编译
2014.9.2:加if cmp 的&&语句
2014.9.3:加value编译，下一步加codegen的输出
2014.9.4:加codegen的输出，下一步加运行
2014.9.5:加dump，下一步加运行
2014.9.5:加参数传递和简单运行，下一步加指令解析逻辑
2014.9.6:加错误信息，支持重载，加解释器和压栈，下一步加指令解析逻辑
2014.9.8:加assign的指令解析逻辑，下一步加return的
2014.9.10:修复bug，下一步解析3.fk
2014.9.12:解析3.fk成功，下一步加浮点数的支持
2014.9.13:加浮点数的支持，下一步解析4.fk
2014.9.14:加return的支持，已经能完成数学运算，下一步解析8.fk的if else指令
2014.9.15:加win32的支持，已能成功运行，下一步优化下运行时效率
2014.9.16:基本优化完毕，剩下的就是binary的map了，下一步解析8.fk
2014.9.16:解析8.fk完成，下一步解析9.fk
2014.9.16:解析9.fk完成，下一步添加内置函数，print接口
2014.9.17:执行9.fk比较和lua的差距大约差两倍，下一步加++和--接口，加完再进一步比较下
2014.9.17:优化后，执行9.fk比较和lua的差距是6s和7s，比较接近，下一步加++和--接口，加完再进一步比较下
2014.9.17:加+= -=等接口减少复制，加完9.fk效率和lua一样了
2014.9.18:后面继续对var进行优化，字符串改为引用方式，增加字符串池，去掉bool和int，一律用float，class改struct，构造析构能省则省，不行替换成宏
2014.9.18:改成lua方式，所有临时数据存放在fuck结构体中
2014.9.18:底层优化成c风格的，字符串处理todo，目前比lua速度还快点，运行9.fk 300w次，win下时间1s，linux下4s，lua分别是1s、5s
2014.9.18:优化func find，现在fuck 10s vs lua 16s，大幅提升性能，下一步加下bin的资源释放
2014.9.19:看了下luajit的实现，是在运行时在内存中编译好汇编码，然后设为可执行，然后再通过函数调用的方式跳转到这里，确实很巧妙，fs也实现下
2014.9.20:开始写fuckjit，把中间代码变成机器码运行
2014.9.21:fuckjit的2.fk调试通过，下一步编译3.fk
2014.9.22:添加数学运算，7.fk编译通过，jit比inter快3倍，下一步搞跳转语句
2014.9.23:搞定加等号和大与判断，下一步搞jmp就可以支持if和while了
2014.9.24:搞定jump，12.fk编译通过，速度果然快很多倍，下一步移植到win下
2014.9.25:win下不能支持嵌入汇编，加了个.asm，下一步写asm调用jit函数
2014.9.26:win下jit调试通过，记得得push各种寄存器再pop，下一步做函数调用
2014.9.28:加funcmap做函数的索引，下一步先加字符串操作
2014.10.1:加stringheap空的
2014.10.2:stringheap加alloc函数，先不考虑gc和hash，下一步做字符串的操作
2014.10.2:字符串的判断返回传参没问题，下一步做函数的调用
2014.10.23:加解释器函数的调用，已能解释执行，下一步加C函数的调用
2014.10.24:加C函数绑定，下一步加执行
2014.11.3:还是需要一个通用的hashmap，下一步加动态大小的hashmap
2014.11.3:加release和debug的build选择，下一步加动态大小的hashmap
2014.11.4:加动态大小的hashmap，下一步初步替换掉stringheap
2014.11.6:替换掉stringheap，下一步加c函数的映射
2014.11.6:加c函数的映射，去掉funcmap，下一步加C函数的执行
2014.11.6:加C函数的执行，17.fk运行ok，下一步加类函数的执行
2014.11.8:加类函数的执行，18.fk运行ok，下一步可以加下jit的函数调用了
2014.11.11:比较了release下的性能，优于lua，下一步可以加下jit的函数调用了
2014.11.11:更改为fakescript，下一步可以加下jit的函数调用了
2014.11.12:修复bug，函数调用的jit暂时停止，先做字符串库gc和整体的内存释放
2014.11.13:加错误提示，下一步修改函数注册和脚本解析的处理
2014.11.14:修复bug
2014.11.16:加while true和break，下一步加for语句
2014.11.17:加for语句，下一步加多返回值，jit暂且放下
2014.11.17:加多返回值，jit暂且放下
2014.11.17:加profile，下一步解决int64丢失数据的问题
2014.11.18:int64做一个特殊的类型uuid，不参与运算
2014.11.19:加array结构，加processor，routine，结束多线程，只做假多线程，加重入次数
2014.11.20:加fake语法，支持假多线程
2014.11.21:加array和map容器，性能稍微损耗了点，9.fk从8s降到了9s
2014.11.22:改进funcmap查询
2014.11.23:去掉无用参数，fakescript基本告一段落，后面可以把stringhash优化下，用硬件指令
2014.11.26:下一步加混淆和二进制加密
2014.11.28:fix platform build on amazon linux
2014.12.4:修复下退出时的内存泄露
2015.1.6:加const定义，下一步完善错误提示，增加用户级的错误回调
2015.1.6:完善一部分错误提示，下一步加文件名和行号
2015.1.7:加文件名和行号，下一步加包的概念
2015.1.8:fix amezon build，下一步加包的概念
2015.1.19:加包的语法，下一步实现包逻辑，xx包的查找从./*.fk,./xx/*.fk查找
2015.1.21:加parser，实现为include的方式
2015.1.22:实现包的方式
2015.1.23:添加struct定义，底层是map实现，添加package，朝着工具方向前进
2015.1.23:添加package list
2015.1.26:添加package file
2015.1.27:添加LIKE和UNLIKE
2015.1.30:添加buffer net
2015.2.2:完善语法
2015.2.3:加buffer，需要加test库
2015.2.4:加selector，下一步加socket相关
2015.2.4:加socket相关，下一步加yield
2015.2.5:加socket
2015.2.6:加yield
2015.2.10:加file readall，下一步加xml解析
2015.2.12:加switch case
2015.2.13:加string
2015.2.19:加float format
2015.2.20:加fake bin
2015.2.28:修改xml package的bug，下一步加模板引擎
2015.3.4:加range typeof，开始加template
2015.3.6:template加.name的规则，下一步加array
2015.3.9:template加range的规则，下一步加if和usercall
2015.3.10:修改掉底层的hashmap，改成节点不被释放，强化了热更新，下一步在template里嵌入脚本
2015.3.11:修改热更新机制，改成退出函数时判断是否替换，下一步在template里嵌入脚本
2015.3.12:template里嵌入脚本ok，下一步加下消息包的加解密
2015.3.16:做一个jit的计划，函数的起始堆栈放入参、常量值、出参，子函数调用通过ps中转，多线程处理，下一步还是加消息包的加解密
2015.3.18:加:=语法，下一步加elseif语法
2015.3.18:加elseif语法，下一步加消息包的加解密
2015.3.20:消息包的加解密具体情况再用template做吧，先做jit，先把jit的架构同步到interpreter一致，热更新等，再处理下函数调用支持多返回值的内部函数调用
2015.4.3:完成协程库了，开始搞jit，先把外围搞好
2015.4.7:搞jit先忽略掉container和routine的情况，把函数调用做了
2015.4.9:jit搞开关，默认关闭，下一步加函数的调用，完善运算后的type设置
2015.4.10:开始替换jit函数调用，有core
2015.4.10:jit函数调用基本ok，下一步调整下内建函数的参数返回顺序，8.fk有问题，估计是分支问题
2015.4.11:8.fk ok，下一步修改参数返回顺序，已经调整变量大下看看
2015.4.11:顺序ok，sizet变量调小了，下一步可以考虑jit支持更多的特性
2015.4.12:win ok，下一步可以考虑jit支持更多的特性，还有常量map嵌套定义
2015.5.12:fix build
2015.5.18:fix jit bug
2015.7.09:fakescript复杂脚本比lua慢一倍，还需要进一步优化
2015.7.10:调整net库，加net的测试脚本，下一步加消息包的fake生成，为机器人准备
2015.7.14:加save load功能，清理test testjit，都用fake。下一步先放下save load，重构下解释器
2015.7.15:重构ok,primes减少了3秒，下一步再优化下for循环
2015.7.15:优化for循环ok，与lua的差距只有1s了。下一步优化下cmp和jmp，合二为一
2015.7.15:cmp和jne合二为一，还比lua快1s了。for循环进一步优化，速度更快一步。下一步做save load
2015.7.17:完成save load
2015.7.18:给fake加print result和time，修复win下的bug
2015.7.20:加编译为exe的功能
2015.7.23:修复template的bug
2015.7.28:给template加个do的功能
2015.7.30:加ide，方便调试
2015.7.31:去掉ide，mfc还是太麻烦，update to vs2015
2015.8.3:加ide的保存、statusbar，加了两个窗口做variant和bytecode的查看，引入fake库
2015.8.4:加ide的高亮
2015.8.5:加run的menu，下一步加parse逻辑
2015.8.5:加parse逻辑，下一步加run，已经修改print函数
2015.8.6:加run，下一步加调试单步断点
2015.8.7:修改cur processor，为调试功能做准备，调试断点后，即中途返回调用程序，保留cur processor下次再继续
2015.8.7:修改错误提示，改为直接把文件名行号函数名传给错误处理
2015.8.7:增加step mod，单步执行，为调试做准备，下一步显示变量，先在fake.exe上增加功能再移植到ide
2015.8.10:加fake.exe单步执行，修改使行号准确，下一步显示当前附近字节码
2015.8.11:完善命令行调试功能，增加l,n,s,si,ni,bt
2015.8.12:完善命令行调试功能，增加b,d,en,dis,c,p,set
2015.8.13:命令行调试bug，增加ide的f6 f9 f10 f11，下一步加call stack
2015.8.14:ide callstack完成，命令行调试加routine的显示，下一步加ide的routine，for循环的行号优化
2015.8.17:完善命令行调试
2015.8.19:ide完成基本功能
2015.8.24:修改网络底层错误处理
2015.8.25:修改网络底层错误处理
2015.9.6:修改ide bug
2015.9.23:增加nodelay keepalive
2015.10.29:修复bug
2015.10.30:把debug代码挪到lib中，这样可以直接在嵌入状态进行命令行调试
2015.11.10:修复bug，增加string package接口
2015.12.9:指针增加type，class mem call可重名，下一步加字符串粘结符
2015.12.10:加字符串粘结符
2015.12.18:加错误提示
2015.12.22:加全局常量，方便文件间的读取
2015.12.23:加字节流与C的交互，方便参数传递
2015.12.29:完善buffer的接口
2015.12.30:添加json package
2015.12.31:下一步搞搞container的jit，可以通过栈上的位置left right dest中转，再保存回堆里的container
2016.1.5:修复指针type的bug
2016.1.6:修复出错情况，不能热更新的bug
2016.1.7:添加format方便拼字符串，修复bug
2016.1.11:加两个math函数
2016.1.12:字符串传递异常情况处理
2016.1.14:json加个方便机器的接口
2016.1.15:jit添加container的支持，下一步加jit的字符串粘结符、类成员函数调用、for优化
2016.1.16:update ide exe
2016.1.18:修正hashmap可能的泄漏问题，开始加map array的const定义
2016.1.19:支持常量map array的定义，包括不能修改的判定，添加dumpstat接口，修复1.2e3这样的解析，加getconst获取dostring得来的常量，优化string replace
2016.1.20:优化hashmap的内存，添加jit的mem func call
2016.1.21:加内存监控，优化dump输出
2016.1.22:优化内存，下一步继续优化内存，现在解析59.lua就好几百M
2016.1.27:修复运算符优先级bug
2016.1.29:修复除0判断bug
2016.2.1:添加模板参数
2016.3.23:添加heap profiler，连续dostring多次会内存增加，应该有bug
2016.3.24:加60.fk，好好研究下内存占用
2016.3.28:加memblock，优化内存占用，flex bison解析会消耗200M内存，linux释放还在，windows释放了没有了，16M文本加载占用120M内存
2016.3.29:去掉难看的pool node
2016.3.30:修复save load const
2016.5.10:bind func buildin func 传参数个数判断
2016.5.13:老宋帮忙优化了下readme
2016.8.2:增加了c:memfunc1():memfunc2()和a()(arg1)(arg2)的语法
2016.8.30:修复for循环里continue跳过end block的bug
2016.9.7:更新下ide，加下null关键字和java版本统一
2016.9.12:从java版本移植字节码优化过来，34.fk还有问题
2016.9.13:修复把传参优化掉的bug
2016.10.11:修改下59.lua文件名
2016.10.11:修改下for loop的实现，修改jit在opt下的bug，目前只剩下sleep yield fake未能实现，下一步加gc
2017.8.7:添加一些接口
2017.10.11:添加tolong函数
2018.1.17:修复优化的bug
2019.4.18:更名fake，重新组织项目，去掉windows的支持，对远期有利，去掉不必要的buildin
2019.4.23:centos7编译通过,添加test
2019.4.24:修改完test，剩下的有修改fakebin编译的bug、ide编译、gc
2019.4.26:修改完fakebin编译的bug、ide编译，剩下gc
2019.5.6:添加了string的gc，编译通过，下一步测试效果
2019.5.7:拆分gen.sh不再每次都生成，下一步写个测试脚本，测试gc效果
2019.6.11:写个测试脚本，测试gc string效果，有崩溃问题
2019.6.12:修复崩溃问题，string gc貌似没问题，下一步加上其他的gc，加上pointer gc，剩下container gc，还有一个container循环引用的gc问题
2019.6.15:添加mingw，加完 gc，下一步测试下效率，再看看jit下面的gc
2019.6.24:修复gc bug，下一步测试下效率，再看看jit下面的gc
2019.6.26:修复gc bug，下一步测试下效率，再看看jit下面的gc
2019.7.2:修复gc bug，下一步测试下效率，再看看jit下面的gc
2019.7.10:下载了最新的lua5.3，测试了下性能，发现fake耗时是lua的1.5-2倍，之前用lua_tinker的方式跑，lua的测试不准确。需要优化下，目前看loop的差距比较大


